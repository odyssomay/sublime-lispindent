{
	"languages": {
		"clojure": {
			"detect": ".*\\.(clj|cljs)$",
			"default_indent": "function",
			"regex": "(ns|fn|def[^\\s]*|bound-fn|if|if-not|case|condp|when|while|when-not|when-first|do|future|comment|doto|locking|proxy|with-open|with-precision|with-local-vars|reify|deftype|defrecord|defprotocol|extend|extend-protocol|extend-type|try|catch|finally|let|letfn|binding|loop|for|doseq|dotimes|when-let|if-let|defstruct|struct-map|assoc|defmethod|testing|deftest|use-fixtures|handler-case|handle|dotrace|deftrace)$"
		},

		"scheme": {
			"detect": ".*\\.(ss|scm|sch|rkt)$",
			"default_indent": "function",
			"regex": "(begin|case|delay|do|define|lambda|let|let\\*|letrec|let-values|let\\*-values|sequence|let-syntax|letrec-syntax|syntax-rules|syntax-case|call-with-input-file|with-input-from-file|with-input-from-port|call-with-output-file|with-output-to-file|with-output-to-port|call-with-values|dynamic-wind)$"
		},

		"common_lisp": {
			"detect": ".*\\.(lsp|lisp)$",
			"default_indent": "function",
			"regex": "(catch|defvar|defclass|defconstant|defcustom|defparameter|defconst|define-condition|define-modify-macro|defsetf|defun|defgeneric|define-setf-method|define-self-expander|defmacro|defsubst|deftype|defmethod|defpackage|defstruct|dolist|dotimes|lambda|let|let\\*|prog1|prog2|unless|when)$"
		}
	}
}